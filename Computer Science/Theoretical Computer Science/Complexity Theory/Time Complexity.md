# Time Complexity

시간 복잡도(time complexity)는 알고리즘의 실행 시간을 입력 크기에 대한 함수로 표현한 것입니다. 이는 알고리즘이 문제를 해결하는 데 얼마나 많은 시간이 걸리는지를 추정하는 방법으로, 알고리즘의 효율성을 분석하는 데 중요한 역할을 합니다.

시간 복잡도는 대개 빅 오(Big O) 표기법을 사용하여 표현됩니다. 빅 오 표기법은 알고리즘의 성능을 최악의 경우를 기준으로 나타내며, 입력 크기가 증가함에 따라 알고리즘 실행 시간이 어떻게 변화하는지를 설명합니다. 예를 들어, O(n)은 선형 시간 복잡도를 나타내며, 입력 크기에 비례하여 실행 시간이 증가합니다. O(n^2)은 이차 시간 복잡도를 나타내며, 입력 크기의 제곱에 비례하여 실행 시간이 증가합니다.

알고리즘의 시간 복잡도를 분석함으로써, 프로그래머들은 다양한 알고리즘들 중에서 어떤 것이 주어진 문제를 더 효율적으로 해결할 수 있는지를 판단할 수 있습니다. 일반적으로 시간 복잡도가 낮은 알고리즘이 큰 입력 크기에 대해 더 빠르게 실행되므로 선호됩니다. 하지만 실제 상황에서는 상수 계수, 메모리 사용량, 코드의 간결성 등 다양한 요소들도 고려되어야 합니다.

시간 복잡도를 이해하는 데 도움이 될 수 있도록 파이썬 예제를 통해 설명하겠습니다.

예제 1: 선형 시간 복잡도 O(n)

```py
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```
이 예제에서 linear_search 함수는 리스트 arr에서 target 값을 찾습니다. 최악의 경우, 리스트의 모든 원소를 검사해야 하므로 시간 복잡도는 O(n)입니다.

예제 2: 이차 시간 복잡도 O(n^2)

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
```
이 예제에서 bubble_sort 함수는 버블 정렬 알고리즘을 사용하여 리스트 arr를 정렬합니다. 이 알고리즘은 이중 반복문을 사용하여 최악의 경우 시간 복잡도가 O(n^2)입니다.

예제 3: 로그 시간 복잡도 O(log n)

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```
이 예제에서 binary_search 함수는 정렬된 리스트 arr에서 target 값을 이진 검색 알고리즘을 사용하여 찾습니다. 이 알고리즘은 각 반복에서 검색 범위를 절반으로 줄이므로 시간 복잡도는 O(log n)입니다.

이러한 예제들을 통해 시간 복잡도가 알고리즘의 실행 시간에 어떻게 영향을 미치는지 파이썬 코드를 통해 이해할 수 있습니다. 시간 복잡도를 고려함으로써 프로그래머들은 입력 크기가 커질 때 알고리즘이 어떻게 작동할지 예측하고, 효율적인 코드를 작성할 수 있습니다.
